# Configuration file for the Sphinx documentation builder.
#
# For the full list of built-in configuration values, see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Project information -----------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information

project = "data_juicer"
copyright = "2024, Data-Juicer Team"
author = "Data-Juicer Team"

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#

from data_juicer import __version__ as version
import re
import os
import sys
import shutil
from pathlib import Path

sys.path.insert(0, os.path.abspath("../../"))

# -- General configuration ---------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration

extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.autosummary",
    "sphinx.ext.viewcode",
    "sphinx.ext.napoleon",
    "sphinx.ext.autosectionlabel",
    "myst_parser",
    "sphinx_copybutton",
    "sphinx_multiversion",
    # 'sphinxcontrib.apidoc', # TODO: Replace with sphinx.ext.apidoc when sphinx>=8.2
]

myst_heading_anchors = 4
smv_tag_whitelist = r'^v\d+\.\d+\.\d+$'
smv_branch_whitelist = r"^main$"
smv_released_pattern = r"^tags/.*$"
smv_released_pattern = r"^refs/tags/v\d+\.\d+\.\d+$"

# apidoc set
apidoc_module_dir = "../../../data_juicer"
apidoc_output_dir = "./"

# Prefix document path to section labels, otherwise autogenerated labels would
# look like 'heading' rather than 'path/to/file:heading'
autosectionlabel_prefix_document = True
autosummary_generate = True
autosummary_ignore_module_all = False

autodoc_member_order = "bysource"

templates_path = ["_templates"]
exclude_patterns = ["build"]

# -- Options for HTML output -------------------------------------------------

html_theme = "furo"
html_title = "data-juicer"
# html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

html_css_files = [
    "custom.css",
]

html_js_files = ["custom.js"]

html_sidebars = {
    "**": [
        "sidebar/brand.html",
        "sidebar/search.html",
        "sidebar/scroll-start.html",
        "sidebar/navigation.html",
        "sidebar/scroll-end.html",
        "sidebar/bottom_menu.html",
    ],
}

# language settings
language = "en"
locale_dirs = ["locale/"]  # path is example but recommended.
gettext_compact = False  # optional.

# list of supported languages
supported_languages = {
    "en": "English",
    "zh-CN": "简体中文",
    # 'ja': '日本語',
}


def get_lang_link(language, pagename, lang_code, non_zh_pages=[], current_version=""):
    if current_version:
        base_path = "../../"
    else:
        base_path = "../"

    def norm_pagename(pagename):
        return os.path.normpath(pagename)

    norm_non_zh_pages = set(map(norm_pagename, non_zh_pages))
    target_page = pagename
    if language == "zh-CN" and pagename.endswith("_ZH"):
        target_page = pagename[:-3]
    if lang_code == "zh-CN" and not pagename.endswith("_ZH"):
        if norm_pagename(pagename) not in norm_non_zh_pages:
            target_page += "_ZH"
    return f"{base_path}{lang_code}/{current_version}{target_page}.html"


html_context = {
    "supported_languages": supported_languages,
    "get_lang_link": get_lang_link,
}
# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]


def find_zh_exclusions(app, config):
    """
    Find Chinese translation files to exclude when building English documentation
    """
    non_zh_pages = set()
    zh_exclusions = []
    for root, dirs, files in os.walk(app.srcdir):
        for file in files:
            # Check for files with English base names and corresponding _ZH versions
            if not file.endswith("_ZH.md") and not file.endswith("_ZH.rst"):
                base_name, ext = os.path.splitext(file)
                zh_file = f"{base_name}_ZH{ext}"
                zh_file_path = os.path.join(root, zh_file)
                rel_path = os.path.normpath(
                    os.path.relpath(os.path.join(root, file), app.srcdir)
                )
                # If Chinese version exists, add to exclusions
                if os.path.exists(zh_file_path):
                    # Convert to relative path from source directory
                    zh_exclusions.append(rel_path)
                else:
                    non_zh_pages.add(
                        os.path.normpath(
                            os.path.relpath(os.path.join(root, base_name), app.srcdir)
                        )
                    )

    if config.language == "zh-CN":
        config.exclude_patterns.extend(zh_exclusions)
    else:
        config.exclude_patterns.extend(["*_ZH*", "**/*_ZH*"])

    app.config.html_context.setdefault("non_zh_pages", set()).update(non_zh_pages)


def skip(app, what, name, obj, would_skip, options):
    if name == "__init__":
        return False
    return would_skip


def create_symlinks(app, config):
    # Use app.srcdir to get the current version of the document source directory
    source_dir = Path(app.srcdir)
    project_root = source_dir.parent.parent.parent

    for md_file in project_root.rglob("*.md"):
        if "outputs" in str(md_file) or "sphinx_doc" in str(md_file):
            continue

        rel_path = md_file.relative_to(project_root)
        target = source_dir / rel_path

        target.parent.mkdir(parents=True, exist_ok=True)

        if not target.exists():
            rel_source = os.path.relpath(md_file, target.parent)
            target.symlink_to(rel_source)
    
    find_zh_exclusions(app, config)


def copy_sphinx_doc(app):
    source_dir = Path(app.srcdir)
    project_root = source_dir.parent.parent.parent
    sphinx_doc_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "../.."))
    shutil.copytree(sphinx_doc_path, project_root / "docs", dirs_exist_ok=True)


def process_doc_links(app, docname, source):
    repo_base_url = "https://github.com/modelscope/data-juicer/blob/main/"


    def link_replacer(match):
        link_text = match.group(1)
        relative_path = match.group(2)

        current_doc_dir = os.path.dirname(docname)

        absolute_path = os.path.normpath(os.path.join(current_doc_dir, relative_path))

        full_github_link = f"{repo_base_url}{absolute_path}"

        return f"[{link_text}]({full_github_link})"

    pattern = r"\[([^\]]+)\]\((?!http|#)([^)]*(?<!\.md))\)"
    source[0] = re.sub(pattern, link_replacer, source[0])

    return source[0]


def process_read(app, docname, source):
    source[0] = process_doc_links(app, docname, source)

def process_include(app, relative_path, parent_docname, source):
    source[0] = process_doc_links(app, relative_path, source)
    

def setup(app):
    app.connect("config-inited", create_symlinks)
    app.config.root_doc = "index_ZH" if app.config.language == "zh-CN" else "index"
    if app.config.smv_current_version != "main":
        app.connect("builder-inited", copy_sphinx_doc)
    app.connect("source-read", process_read)
    app.connect('include-read', process_include)
    app.connect("autodoc-skip-member", skip)
